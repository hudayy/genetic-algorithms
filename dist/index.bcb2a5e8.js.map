{"mappings":"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","sources":["jet.js"],"sourcesContent":["class Jet extends NeuralNet {\n    constructor() {\n        super(nodeLengths, learningRate, false, true)\n        this.previousOutput = Array.from({ length: generationLength }, () => Array(nodeLengths[nodeLengths.length - 1]).fill(0));\n        this.bestOutput = this.previousOutput;\n        this.bestInput = Array.from({ length: generationLength }, () => Array(nodeLengths[0]).fill(0));\n        this.fitnessQueue = [];\n        this.reset();\n    }\n\n    reset() {\n        if (!deterministic) this.learn();\n        this.fitnessEnqueue(this.fitness());\n        this.setPeakFitness();\n        this.x = 0;\n        this.y = 10;\n        this.vx = 0;\n        this.vy = 0;\n        this.previousInput = [];\n\n        this.lifeTime = generationLength;\n        this.finishTime = 0;\n    }\n\n    fitnessEnqueue(fitness) {\n        this.fitnessQueue.push(fitness);\n        if (this.fitnessQueue.length > fitnessQueueLength) this.fitnessQueue.shift();\n    }\n\n    averageFitness() {\n        return this.fitnessQueue.reduce((a, b) => a + b, 0) / this.fitnessQueue.length;\n    }\n\n    setPeakFitness() {\n        if (this.fitness() > peakFitness) {\n            peakFitness = this.fitness()\n        }\n    }\n\n    learn() {\n        if (this.fitness() > this.averageFitness()) {\n            this.bestOutput = this.previousOutput;\n            this.bestInput = this.previousInput;\n        }\n        this.sgd(this.bestInput, this.bestOutput, learningRate);\n    }\n\n    dead() {\n        if (this.x < -50) return true;\n        if (this.x >= 50) return true;\n        if (this.y >= 100) return true;\n        if (this.y < 0) return true;\n\n        for (let rect of rects) {\n            if (rect.checkForRect(this.x, this.y)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    done() {\n        if (this.dead()) {\n            return true;\n        }\n        if (this.distToGoal() < 5) {\n            return true;\n        }\n        return false;\n    }\n\n    update(step) {\n        this.inputs = [this.distToGoal(), this.distToWall()];\n        this.previousInput.push(this.inputs);\n        this.output = convertToOneHot(this.forward(this.inputs, temperature), deterministic);\n        this.previousOutput[step] = this.output;\n\n        const angle = (this.output.findIndex(value => value === 1) * Math.PI) / 4;\n\n        this.vx += Math.cos(angle);\n        this.vy += Math.sin(angle);\n\n        this.x += this.vx * jetSpeed;\n        this.y += this.vy * jetSpeed;\n    }\n\n    triCoords() {\n        const sideLength = 2, h = Math.sqrt(3) * sideLength / 2, r = Math.atan2(this.vy, this.vx) + Math.PI / 2;\n        const points = [\n            [this.x, this.y - h * 0.5],\n            [this.x - sideLength / 2, this.y + h / 2],\n            [this.x + sideLength / 2, this.y + h / 2]\n        ];\n        const [cx, cy] = points.reduce(([a, b], [px, py]) => [a + px / 3, b + py / 3], [0, 0]);\n        return points.flatMap(([px, py]) => {\n            const dx = px - cx, dy = py - cy;\n            return [dx * Math.cos(r) - dy * Math.sin(r) + cx, dx * Math.sin(r) + dy * Math.cos(r) + cy];\n        });\n    }\n\n    draw(color) {\n        push();\n        strokeWeight(0.1);\n        stroke(...color);\n        fill(128, 128, 128, 10);\n        triangle(...this.triCoords());\n        pop();\n    }\n\n    fitness() {\n        let fitness = 0;\n        if (this.finishTime) {\n            fitness = generationLength - this.finishTime;\n        } else {\n            fitness += -this.distToGoal();\n            if (this.dead()) fitness -= 200;\n        }\n        return fitness;\n    }\n\n    distToWall() {\n        let minDist = Infinity;\n\n        for (let rect of rects) {\n            const closestX = Math.max(rect.x, Math.min(this.x, rect.xBound));\n            const closestY = Math.max(rect.y, Math.min(this.y, rect.yBound));\n            const dist = Math.sqrt((closestX - this.x) ** 2 + (closestY - this.y) ** 2);\n            minDist = Math.min(minDist, dist);\n        }\n\n        return minDist;\n    }\n\n    distToGoal() {\n        return dist(this.x, this.y, goalX, goalY);\n    }\n}"],"names":[],"version":3,"file":"index.bcb2a5e8.js.map","sourceRoot":"/__parcel_source_root/"}